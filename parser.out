Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> block
Rule 1     block -> block sentence
Rule 2     block -> <empty>
Rule 3     sentence -> declare SEMICOLON
Rule 4     sentence -> assign SEMICOLON
Rule 5     sentence -> control SEMICOLON
Rule 6     sentence -> read SEMICOLON
Rule 7     sentence -> write SEMICOLON
Rule 8     declare -> TYPE NAME
Rule 9     declare -> TYPE NAME ASSIGN expr
Rule 10    assign -> NAME ASSIGN expr
Rule 11    control -> while
Rule 12    control -> if
Rule 13    control -> BREAK
Rule 14    control -> CONTINUE
Rule 15    while -> WHILE LP expr RP COLON block END
Rule 16    if -> IF LP expr RP COLON block elif else END
Rule 17    elif -> elif ELIF LP expr RP COLON block
Rule 18    elif -> <empty>
Rule 19    else -> ELSE COLON block
Rule 20    else -> <empty>
Rule 21    aexpr -> aexpr BOR aexpr
Rule 22    aexpr -> aexpr BXOR aexpr
Rule 23    aexpr -> aexpr BAND aexpr
Rule 24    aexpr -> aexpr BRSHIFT aexpr
Rule 25    aexpr -> aexpr BLSHIFT aexpr
Rule 26    aexpr -> aexpr PLUS aexpr
Rule 27    aexpr -> aexpr MINUS aexpr
Rule 28    aexpr -> aexpr TIMES aexpr
Rule 29    aexpr -> aexpr MODS aexpr
Rule 30    aexpr -> aexpr DIVIDES aexpr
Rule 31    aexpr -> aexpr EXP aexpr
Rule 32    aexpr -> MINUS aexpr
Rule 33    aexpr -> BNOT aexpr
Rule 34    aexpr -> LP aexpr RP
Rule 35    aexpr -> TYPE LP aexpr RP
Rule 36    aexpr -> INT
Rule 37    aexpr -> FLOAT
Rule 38    aexpr -> BOOL
Rule 39    aexpr -> NAME
Rule 40    expr -> expr OR expr
Rule 41    expr -> expr AND expr
Rule 42    expr -> aexpr EQ aexpr
Rule 43    expr -> aexpr NEQ aexpr
Rule 44    expr -> aexpr GT aexpr
Rule 45    expr -> aexpr GET aexpr
Rule 46    expr -> aexpr LT aexpr
Rule 47    expr -> aexpr LET aexpr
Rule 48    expr -> NOT expr
Rule 49    expr -> aexpr
Rule 50    read -> READ NAME
Rule 51    write -> WRITE expr

Terminals, with rules where they appear

AND                  : 41
ASSIGN               : 9 10
BAND                 : 23
BLSHIFT              : 25
BNOT                 : 33
BOOL                 : 38
BOR                  : 21
BREAK                : 13
BRSHIFT              : 24
BXOR                 : 22
COLON                : 15 16 17 19
CONTINUE             : 14
DIVIDES              : 30
ELIF                 : 17
ELSE                 : 19
END                  : 15 16
EQ                   : 42
EXP                  : 31
FLOAT                : 37
GET                  : 45
GT                   : 44
IF                   : 16
INT                  : 36
LET                  : 47
LP                   : 15 16 17 34 35
LT                   : 46
MINUS                : 27 32
MODS                 : 29
NAME                 : 8 9 10 39 50
NEQ                  : 43
NOT                  : 48
OR                   : 40
PLUS                 : 26
READ                 : 50
RP                   : 15 16 17 34 35
SEMICOLON            : 3 4 5 6 7
TIMES                : 28
TYPE                 : 8 9 35
WHILE                : 15
WRITE                : 51
error                : 

Nonterminals, with rules where they appear

aexpr                : 21 21 22 22 23 23 24 24 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 33 34 35 42 42 43 43 44 44 45 45 46 46 47 47 49
assign               : 4
block                : 1 15 16 17 19 0
control              : 5
declare              : 3
elif                 : 16 17
else                 : 16
expr                 : 9 10 15 16 17 40 40 41 41 48 51
if                   : 12
read                 : 6
sentence             : 1
while                : 11
write                : 7

Parsing method: LALR

state 0

    (0) S' -> . block
    (1) block -> . block sentence
    (2) block -> .

    TYPE            reduce using rule 2 (block -> .)
    NAME            reduce using rule 2 (block -> .)
    BREAK           reduce using rule 2 (block -> .)
    CONTINUE        reduce using rule 2 (block -> .)
    READ            reduce using rule 2 (block -> .)
    WRITE           reduce using rule 2 (block -> .)
    WHILE           reduce using rule 2 (block -> .)
    IF              reduce using rule 2 (block -> .)
    $end            reduce using rule 2 (block -> .)

    block                          shift and go to state 1

state 1

    (0) S' -> block .
    (1) block -> block . sentence
    (3) sentence -> . declare SEMICOLON
    (4) sentence -> . assign SEMICOLON
    (5) sentence -> . control SEMICOLON
    (6) sentence -> . read SEMICOLON
    (7) sentence -> . write SEMICOLON
    (8) declare -> . TYPE NAME
    (9) declare -> . TYPE NAME ASSIGN expr
    (10) assign -> . NAME ASSIGN expr
    (11) control -> . while
    (12) control -> . if
    (13) control -> . BREAK
    (14) control -> . CONTINUE
    (50) read -> . READ NAME
    (51) write -> . WRITE expr
    (15) while -> . WHILE LP expr RP COLON block END
    (16) if -> . IF LP expr RP COLON block elif else END

    TYPE            shift and go to state 16
    NAME            shift and go to state 11
    BREAK           shift and go to state 13
    CONTINUE        shift and go to state 15
    READ            shift and go to state 4
    WRITE           shift and go to state 9
    WHILE           shift and go to state 5
    IF              shift and go to state 10

    control                        shift and go to state 2
    sentence                       shift and go to state 3
    read                           shift and go to state 8
    declare                        shift and go to state 17
    write                          shift and go to state 7
    while                          shift and go to state 14
    assign                         shift and go to state 12
    if                             shift and go to state 6

state 2

    (5) sentence -> control . SEMICOLON

    SEMICOLON       shift and go to state 18


state 3

    (1) block -> block sentence .

    TYPE            reduce using rule 1 (block -> block sentence .)
    NAME            reduce using rule 1 (block -> block sentence .)
    BREAK           reduce using rule 1 (block -> block sentence .)
    CONTINUE        reduce using rule 1 (block -> block sentence .)
    READ            reduce using rule 1 (block -> block sentence .)
    WRITE           reduce using rule 1 (block -> block sentence .)
    WHILE           reduce using rule 1 (block -> block sentence .)
    IF              reduce using rule 1 (block -> block sentence .)
    END             reduce using rule 1 (block -> block sentence .)
    ELIF            reduce using rule 1 (block -> block sentence .)
    ELSE            reduce using rule 1 (block -> block sentence .)
    $end            reduce using rule 1 (block -> block sentence .)


state 4

    (50) read -> READ . NAME

    NAME            shift and go to state 19


state 5

    (15) while -> WHILE . LP expr RP COLON block END

    LP              shift and go to state 20


state 6

    (12) control -> if .

    SEMICOLON       reduce using rule 12 (control -> if .)


state 7

    (7) sentence -> write . SEMICOLON

    SEMICOLON       shift and go to state 21


state 8

    (6) sentence -> read . SEMICOLON

    SEMICOLON       shift and go to state 22


state 9

    (51) write -> WRITE . expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . aexpr EQ aexpr
    (43) expr -> . aexpr NEQ aexpr
    (44) expr -> . aexpr GT aexpr
    (45) expr -> . aexpr GET aexpr
    (46) expr -> . aexpr LT aexpr
    (47) expr -> . aexpr LET aexpr
    (48) expr -> . NOT expr
    (49) expr -> . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    NOT             shift and go to state 32
    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    expr                           shift and go to state 30
    aexpr                          shift and go to state 25

state 10

    (16) if -> IF . LP expr RP COLON block elif else END

    LP              shift and go to state 34


state 11

    (10) assign -> NAME . ASSIGN expr

    ASSIGN          shift and go to state 35


state 12

    (4) sentence -> assign . SEMICOLON

    SEMICOLON       shift and go to state 36


state 13

    (13) control -> BREAK .

    SEMICOLON       reduce using rule 13 (control -> BREAK .)


state 14

    (11) control -> while .

    SEMICOLON       reduce using rule 11 (control -> while .)


state 15

    (14) control -> CONTINUE .

    SEMICOLON       reduce using rule 14 (control -> CONTINUE .)


state 16

    (8) declare -> TYPE . NAME
    (9) declare -> TYPE . NAME ASSIGN expr

    NAME            shift and go to state 37


state 17

    (3) sentence -> declare . SEMICOLON

    SEMICOLON       shift and go to state 38


state 18

    (5) sentence -> control SEMICOLON .

    TYPE            reduce using rule 5 (sentence -> control SEMICOLON .)
    NAME            reduce using rule 5 (sentence -> control SEMICOLON .)
    BREAK           reduce using rule 5 (sentence -> control SEMICOLON .)
    CONTINUE        reduce using rule 5 (sentence -> control SEMICOLON .)
    READ            reduce using rule 5 (sentence -> control SEMICOLON .)
    WRITE           reduce using rule 5 (sentence -> control SEMICOLON .)
    WHILE           reduce using rule 5 (sentence -> control SEMICOLON .)
    IF              reduce using rule 5 (sentence -> control SEMICOLON .)
    END             reduce using rule 5 (sentence -> control SEMICOLON .)
    ELIF            reduce using rule 5 (sentence -> control SEMICOLON .)
    ELSE            reduce using rule 5 (sentence -> control SEMICOLON .)
    $end            reduce using rule 5 (sentence -> control SEMICOLON .)


state 19

    (50) read -> READ NAME .

    SEMICOLON       reduce using rule 50 (read -> READ NAME .)


state 20

    (15) while -> WHILE LP . expr RP COLON block END
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . aexpr EQ aexpr
    (43) expr -> . aexpr NEQ aexpr
    (44) expr -> . aexpr GT aexpr
    (45) expr -> . aexpr GET aexpr
    (46) expr -> . aexpr LT aexpr
    (47) expr -> . aexpr LET aexpr
    (48) expr -> . NOT expr
    (49) expr -> . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    NOT             shift and go to state 32
    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    expr                           shift and go to state 39
    aexpr                          shift and go to state 25

state 21

    (7) sentence -> write SEMICOLON .

    TYPE            reduce using rule 7 (sentence -> write SEMICOLON .)
    NAME            reduce using rule 7 (sentence -> write SEMICOLON .)
    BREAK           reduce using rule 7 (sentence -> write SEMICOLON .)
    CONTINUE        reduce using rule 7 (sentence -> write SEMICOLON .)
    READ            reduce using rule 7 (sentence -> write SEMICOLON .)
    WRITE           reduce using rule 7 (sentence -> write SEMICOLON .)
    WHILE           reduce using rule 7 (sentence -> write SEMICOLON .)
    IF              reduce using rule 7 (sentence -> write SEMICOLON .)
    END             reduce using rule 7 (sentence -> write SEMICOLON .)
    ELIF            reduce using rule 7 (sentence -> write SEMICOLON .)
    ELSE            reduce using rule 7 (sentence -> write SEMICOLON .)
    $end            reduce using rule 7 (sentence -> write SEMICOLON .)


state 22

    (6) sentence -> read SEMICOLON .

    TYPE            reduce using rule 6 (sentence -> read SEMICOLON .)
    NAME            reduce using rule 6 (sentence -> read SEMICOLON .)
    BREAK           reduce using rule 6 (sentence -> read SEMICOLON .)
    CONTINUE        reduce using rule 6 (sentence -> read SEMICOLON .)
    READ            reduce using rule 6 (sentence -> read SEMICOLON .)
    WRITE           reduce using rule 6 (sentence -> read SEMICOLON .)
    WHILE           reduce using rule 6 (sentence -> read SEMICOLON .)
    IF              reduce using rule 6 (sentence -> read SEMICOLON .)
    END             reduce using rule 6 (sentence -> read SEMICOLON .)
    ELIF            reduce using rule 6 (sentence -> read SEMICOLON .)
    ELSE            reduce using rule 6 (sentence -> read SEMICOLON .)
    $end            reduce using rule 6 (sentence -> read SEMICOLON .)


state 23

    (33) aexpr -> BNOT . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 40

state 24

    (32) aexpr -> MINUS . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 41

state 25

    (42) expr -> aexpr . EQ aexpr
    (43) expr -> aexpr . NEQ aexpr
    (44) expr -> aexpr . GT aexpr
    (45) expr -> aexpr . GET aexpr
    (46) expr -> aexpr . LT aexpr
    (47) expr -> aexpr . LET aexpr
    (49) expr -> aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    EQ              shift and go to state 57
    NEQ             shift and go to state 58
    GT              shift and go to state 42
    GET             shift and go to state 45
    LT              shift and go to state 51
    LET             shift and go to state 53
    OR              reduce using rule 49 (expr -> aexpr .)
    AND             reduce using rule 49 (expr -> aexpr .)
    SEMICOLON       reduce using rule 49 (expr -> aexpr .)
    RP              reduce using rule 49 (expr -> aexpr .)
    BOR             shift and go to state 47
    BXOR            shift and go to state 46
    BAND            shift and go to state 50
    BRSHIFT         shift and go to state 49
    BLSHIFT         shift and go to state 48
    PLUS            shift and go to state 55
    MINUS           shift and go to state 54
    TIMES           shift and go to state 56
    MODS            shift and go to state 52
    DIVIDES         shift and go to state 43
    EXP             shift and go to state 44


state 26

    (34) aexpr -> LP . aexpr RP
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 59

state 27

    (38) aexpr -> BOOL .

    BOR             reduce using rule 38 (aexpr -> BOOL .)
    BXOR            reduce using rule 38 (aexpr -> BOOL .)
    BAND            reduce using rule 38 (aexpr -> BOOL .)
    BRSHIFT         reduce using rule 38 (aexpr -> BOOL .)
    BLSHIFT         reduce using rule 38 (aexpr -> BOOL .)
    PLUS            reduce using rule 38 (aexpr -> BOOL .)
    MINUS           reduce using rule 38 (aexpr -> BOOL .)
    TIMES           reduce using rule 38 (aexpr -> BOOL .)
    MODS            reduce using rule 38 (aexpr -> BOOL .)
    DIVIDES         reduce using rule 38 (aexpr -> BOOL .)
    EXP             reduce using rule 38 (aexpr -> BOOL .)
    EQ              reduce using rule 38 (aexpr -> BOOL .)
    NEQ             reduce using rule 38 (aexpr -> BOOL .)
    GT              reduce using rule 38 (aexpr -> BOOL .)
    GET             reduce using rule 38 (aexpr -> BOOL .)
    LT              reduce using rule 38 (aexpr -> BOOL .)
    LET             reduce using rule 38 (aexpr -> BOOL .)
    OR              reduce using rule 38 (aexpr -> BOOL .)
    AND             reduce using rule 38 (aexpr -> BOOL .)
    SEMICOLON       reduce using rule 38 (aexpr -> BOOL .)
    RP              reduce using rule 38 (aexpr -> BOOL .)


state 28

    (39) aexpr -> NAME .

    BOR             reduce using rule 39 (aexpr -> NAME .)
    BXOR            reduce using rule 39 (aexpr -> NAME .)
    BAND            reduce using rule 39 (aexpr -> NAME .)
    BRSHIFT         reduce using rule 39 (aexpr -> NAME .)
    BLSHIFT         reduce using rule 39 (aexpr -> NAME .)
    PLUS            reduce using rule 39 (aexpr -> NAME .)
    MINUS           reduce using rule 39 (aexpr -> NAME .)
    TIMES           reduce using rule 39 (aexpr -> NAME .)
    MODS            reduce using rule 39 (aexpr -> NAME .)
    DIVIDES         reduce using rule 39 (aexpr -> NAME .)
    EXP             reduce using rule 39 (aexpr -> NAME .)
    EQ              reduce using rule 39 (aexpr -> NAME .)
    NEQ             reduce using rule 39 (aexpr -> NAME .)
    GT              reduce using rule 39 (aexpr -> NAME .)
    GET             reduce using rule 39 (aexpr -> NAME .)
    LT              reduce using rule 39 (aexpr -> NAME .)
    LET             reduce using rule 39 (aexpr -> NAME .)
    OR              reduce using rule 39 (aexpr -> NAME .)
    AND             reduce using rule 39 (aexpr -> NAME .)
    SEMICOLON       reduce using rule 39 (aexpr -> NAME .)
    RP              reduce using rule 39 (aexpr -> NAME .)


state 29

    (36) aexpr -> INT .

    BOR             reduce using rule 36 (aexpr -> INT .)
    BXOR            reduce using rule 36 (aexpr -> INT .)
    BAND            reduce using rule 36 (aexpr -> INT .)
    BRSHIFT         reduce using rule 36 (aexpr -> INT .)
    BLSHIFT         reduce using rule 36 (aexpr -> INT .)
    PLUS            reduce using rule 36 (aexpr -> INT .)
    MINUS           reduce using rule 36 (aexpr -> INT .)
    TIMES           reduce using rule 36 (aexpr -> INT .)
    MODS            reduce using rule 36 (aexpr -> INT .)
    DIVIDES         reduce using rule 36 (aexpr -> INT .)
    EXP             reduce using rule 36 (aexpr -> INT .)
    EQ              reduce using rule 36 (aexpr -> INT .)
    NEQ             reduce using rule 36 (aexpr -> INT .)
    GT              reduce using rule 36 (aexpr -> INT .)
    GET             reduce using rule 36 (aexpr -> INT .)
    LT              reduce using rule 36 (aexpr -> INT .)
    LET             reduce using rule 36 (aexpr -> INT .)
    OR              reduce using rule 36 (aexpr -> INT .)
    AND             reduce using rule 36 (aexpr -> INT .)
    SEMICOLON       reduce using rule 36 (aexpr -> INT .)
    RP              reduce using rule 36 (aexpr -> INT .)


state 30

    (51) write -> WRITE expr .
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr

    SEMICOLON       reduce using rule 51 (write -> WRITE expr .)
    OR              shift and go to state 60
    AND             shift and go to state 61


state 31

    (37) aexpr -> FLOAT .

    BOR             reduce using rule 37 (aexpr -> FLOAT .)
    BXOR            reduce using rule 37 (aexpr -> FLOAT .)
    BAND            reduce using rule 37 (aexpr -> FLOAT .)
    BRSHIFT         reduce using rule 37 (aexpr -> FLOAT .)
    BLSHIFT         reduce using rule 37 (aexpr -> FLOAT .)
    PLUS            reduce using rule 37 (aexpr -> FLOAT .)
    MINUS           reduce using rule 37 (aexpr -> FLOAT .)
    TIMES           reduce using rule 37 (aexpr -> FLOAT .)
    MODS            reduce using rule 37 (aexpr -> FLOAT .)
    DIVIDES         reduce using rule 37 (aexpr -> FLOAT .)
    EXP             reduce using rule 37 (aexpr -> FLOAT .)
    EQ              reduce using rule 37 (aexpr -> FLOAT .)
    NEQ             reduce using rule 37 (aexpr -> FLOAT .)
    GT              reduce using rule 37 (aexpr -> FLOAT .)
    GET             reduce using rule 37 (aexpr -> FLOAT .)
    LT              reduce using rule 37 (aexpr -> FLOAT .)
    LET             reduce using rule 37 (aexpr -> FLOAT .)
    OR              reduce using rule 37 (aexpr -> FLOAT .)
    AND             reduce using rule 37 (aexpr -> FLOAT .)
    SEMICOLON       reduce using rule 37 (aexpr -> FLOAT .)
    RP              reduce using rule 37 (aexpr -> FLOAT .)


state 32

    (48) expr -> NOT . expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . aexpr EQ aexpr
    (43) expr -> . aexpr NEQ aexpr
    (44) expr -> . aexpr GT aexpr
    (45) expr -> . aexpr GET aexpr
    (46) expr -> . aexpr LT aexpr
    (47) expr -> . aexpr LET aexpr
    (48) expr -> . NOT expr
    (49) expr -> . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    NOT             shift and go to state 32
    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    expr                           shift and go to state 62
    aexpr                          shift and go to state 25

state 33

    (35) aexpr -> TYPE . LP aexpr RP

    LP              shift and go to state 63


state 34

    (16) if -> IF LP . expr RP COLON block elif else END
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . aexpr EQ aexpr
    (43) expr -> . aexpr NEQ aexpr
    (44) expr -> . aexpr GT aexpr
    (45) expr -> . aexpr GET aexpr
    (46) expr -> . aexpr LT aexpr
    (47) expr -> . aexpr LET aexpr
    (48) expr -> . NOT expr
    (49) expr -> . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    NOT             shift and go to state 32
    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    expr                           shift and go to state 64
    aexpr                          shift and go to state 25

state 35

    (10) assign -> NAME ASSIGN . expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . aexpr EQ aexpr
    (43) expr -> . aexpr NEQ aexpr
    (44) expr -> . aexpr GT aexpr
    (45) expr -> . aexpr GET aexpr
    (46) expr -> . aexpr LT aexpr
    (47) expr -> . aexpr LET aexpr
    (48) expr -> . NOT expr
    (49) expr -> . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    NOT             shift and go to state 32
    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    expr                           shift and go to state 65
    aexpr                          shift and go to state 25

state 36

    (4) sentence -> assign SEMICOLON .

    TYPE            reduce using rule 4 (sentence -> assign SEMICOLON .)
    NAME            reduce using rule 4 (sentence -> assign SEMICOLON .)
    BREAK           reduce using rule 4 (sentence -> assign SEMICOLON .)
    CONTINUE        reduce using rule 4 (sentence -> assign SEMICOLON .)
    READ            reduce using rule 4 (sentence -> assign SEMICOLON .)
    WRITE           reduce using rule 4 (sentence -> assign SEMICOLON .)
    WHILE           reduce using rule 4 (sentence -> assign SEMICOLON .)
    IF              reduce using rule 4 (sentence -> assign SEMICOLON .)
    END             reduce using rule 4 (sentence -> assign SEMICOLON .)
    ELIF            reduce using rule 4 (sentence -> assign SEMICOLON .)
    ELSE            reduce using rule 4 (sentence -> assign SEMICOLON .)
    $end            reduce using rule 4 (sentence -> assign SEMICOLON .)


state 37

    (8) declare -> TYPE NAME .
    (9) declare -> TYPE NAME . ASSIGN expr

    SEMICOLON       reduce using rule 8 (declare -> TYPE NAME .)
    ASSIGN          shift and go to state 66


state 38

    (3) sentence -> declare SEMICOLON .

    TYPE            reduce using rule 3 (sentence -> declare SEMICOLON .)
    NAME            reduce using rule 3 (sentence -> declare SEMICOLON .)
    BREAK           reduce using rule 3 (sentence -> declare SEMICOLON .)
    CONTINUE        reduce using rule 3 (sentence -> declare SEMICOLON .)
    READ            reduce using rule 3 (sentence -> declare SEMICOLON .)
    WRITE           reduce using rule 3 (sentence -> declare SEMICOLON .)
    WHILE           reduce using rule 3 (sentence -> declare SEMICOLON .)
    IF              reduce using rule 3 (sentence -> declare SEMICOLON .)
    END             reduce using rule 3 (sentence -> declare SEMICOLON .)
    ELIF            reduce using rule 3 (sentence -> declare SEMICOLON .)
    ELSE            reduce using rule 3 (sentence -> declare SEMICOLON .)
    $end            reduce using rule 3 (sentence -> declare SEMICOLON .)


state 39

    (15) while -> WHILE LP expr . RP COLON block END
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr

    RP              shift and go to state 67
    OR              shift and go to state 60
    AND             shift and go to state 61


state 40

    (33) aexpr -> BNOT aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    BOR             reduce using rule 33 (aexpr -> BNOT aexpr .)
    BXOR            reduce using rule 33 (aexpr -> BNOT aexpr .)
    BAND            reduce using rule 33 (aexpr -> BNOT aexpr .)
    BRSHIFT         reduce using rule 33 (aexpr -> BNOT aexpr .)
    BLSHIFT         reduce using rule 33 (aexpr -> BNOT aexpr .)
    PLUS            reduce using rule 33 (aexpr -> BNOT aexpr .)
    MINUS           reduce using rule 33 (aexpr -> BNOT aexpr .)
    TIMES           reduce using rule 33 (aexpr -> BNOT aexpr .)
    MODS            reduce using rule 33 (aexpr -> BNOT aexpr .)
    DIVIDES         reduce using rule 33 (aexpr -> BNOT aexpr .)
    EQ              reduce using rule 33 (aexpr -> BNOT aexpr .)
    NEQ             reduce using rule 33 (aexpr -> BNOT aexpr .)
    GT              reduce using rule 33 (aexpr -> BNOT aexpr .)
    GET             reduce using rule 33 (aexpr -> BNOT aexpr .)
    LT              reduce using rule 33 (aexpr -> BNOT aexpr .)
    LET             reduce using rule 33 (aexpr -> BNOT aexpr .)
    OR              reduce using rule 33 (aexpr -> BNOT aexpr .)
    AND             reduce using rule 33 (aexpr -> BNOT aexpr .)
    SEMICOLON       reduce using rule 33 (aexpr -> BNOT aexpr .)
    RP              reduce using rule 33 (aexpr -> BNOT aexpr .)
    EXP             shift and go to state 44

  ! EXP             [ reduce using rule 33 (aexpr -> BNOT aexpr .) ]
  ! BOR             [ shift and go to state 47 ]
  ! BXOR            [ shift and go to state 46 ]
  ! BAND            [ shift and go to state 50 ]
  ! BRSHIFT         [ shift and go to state 49 ]
  ! BLSHIFT         [ shift and go to state 48 ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 54 ]
  ! TIMES           [ shift and go to state 56 ]
  ! MODS            [ shift and go to state 52 ]
  ! DIVIDES         [ shift and go to state 43 ]


state 41

    (32) aexpr -> MINUS aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    BOR             reduce using rule 32 (aexpr -> MINUS aexpr .)
    BXOR            reduce using rule 32 (aexpr -> MINUS aexpr .)
    BAND            reduce using rule 32 (aexpr -> MINUS aexpr .)
    BRSHIFT         reduce using rule 32 (aexpr -> MINUS aexpr .)
    BLSHIFT         reduce using rule 32 (aexpr -> MINUS aexpr .)
    PLUS            reduce using rule 32 (aexpr -> MINUS aexpr .)
    MINUS           reduce using rule 32 (aexpr -> MINUS aexpr .)
    TIMES           reduce using rule 32 (aexpr -> MINUS aexpr .)
    MODS            reduce using rule 32 (aexpr -> MINUS aexpr .)
    DIVIDES         reduce using rule 32 (aexpr -> MINUS aexpr .)
    EQ              reduce using rule 32 (aexpr -> MINUS aexpr .)
    NEQ             reduce using rule 32 (aexpr -> MINUS aexpr .)
    GT              reduce using rule 32 (aexpr -> MINUS aexpr .)
    GET             reduce using rule 32 (aexpr -> MINUS aexpr .)
    LT              reduce using rule 32 (aexpr -> MINUS aexpr .)
    LET             reduce using rule 32 (aexpr -> MINUS aexpr .)
    OR              reduce using rule 32 (aexpr -> MINUS aexpr .)
    AND             reduce using rule 32 (aexpr -> MINUS aexpr .)
    SEMICOLON       reduce using rule 32 (aexpr -> MINUS aexpr .)
    RP              reduce using rule 32 (aexpr -> MINUS aexpr .)
    EXP             shift and go to state 44

  ! EXP             [ reduce using rule 32 (aexpr -> MINUS aexpr .) ]
  ! BOR             [ shift and go to state 47 ]
  ! BXOR            [ shift and go to state 46 ]
  ! BAND            [ shift and go to state 50 ]
  ! BRSHIFT         [ shift and go to state 49 ]
  ! BLSHIFT         [ shift and go to state 48 ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 54 ]
  ! TIMES           [ shift and go to state 56 ]
  ! MODS            [ shift and go to state 52 ]
  ! DIVIDES         [ shift and go to state 43 ]


state 42

    (44) expr -> aexpr GT . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 68

state 43

    (30) aexpr -> aexpr DIVIDES . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 69

state 44

    (31) aexpr -> aexpr EXP . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 70

state 45

    (45) expr -> aexpr GET . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 71

state 46

    (22) aexpr -> aexpr BXOR . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 72

state 47

    (21) aexpr -> aexpr BOR . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 73

state 48

    (25) aexpr -> aexpr BLSHIFT . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 74

state 49

    (24) aexpr -> aexpr BRSHIFT . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 75

state 50

    (23) aexpr -> aexpr BAND . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 76

state 51

    (46) expr -> aexpr LT . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 77

state 52

    (29) aexpr -> aexpr MODS . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 78

state 53

    (47) expr -> aexpr LET . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 79

state 54

    (27) aexpr -> aexpr MINUS . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 80

state 55

    (26) aexpr -> aexpr PLUS . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 81

state 56

    (28) aexpr -> aexpr TIMES . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 82

state 57

    (42) expr -> aexpr EQ . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 83

state 58

    (43) expr -> aexpr NEQ . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 84

state 59

    (34) aexpr -> LP aexpr . RP
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    RP              shift and go to state 85
    BOR             shift and go to state 47
    BXOR            shift and go to state 46
    BAND            shift and go to state 50
    BRSHIFT         shift and go to state 49
    BLSHIFT         shift and go to state 48
    PLUS            shift and go to state 55
    MINUS           shift and go to state 54
    TIMES           shift and go to state 56
    MODS            shift and go to state 52
    DIVIDES         shift and go to state 43
    EXP             shift and go to state 44


state 60

    (40) expr -> expr OR . expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . aexpr EQ aexpr
    (43) expr -> . aexpr NEQ aexpr
    (44) expr -> . aexpr GT aexpr
    (45) expr -> . aexpr GET aexpr
    (46) expr -> . aexpr LT aexpr
    (47) expr -> . aexpr LET aexpr
    (48) expr -> . NOT expr
    (49) expr -> . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    NOT             shift and go to state 32
    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    expr                           shift and go to state 86
    aexpr                          shift and go to state 25

state 61

    (41) expr -> expr AND . expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . aexpr EQ aexpr
    (43) expr -> . aexpr NEQ aexpr
    (44) expr -> . aexpr GT aexpr
    (45) expr -> . aexpr GET aexpr
    (46) expr -> . aexpr LT aexpr
    (47) expr -> . aexpr LET aexpr
    (48) expr -> . NOT expr
    (49) expr -> . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    NOT             shift and go to state 32
    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    expr                           shift and go to state 87
    aexpr                          shift and go to state 25

state 62

    (48) expr -> NOT expr .
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr

    OR              reduce using rule 48 (expr -> NOT expr .)
    AND             reduce using rule 48 (expr -> NOT expr .)
    SEMICOLON       reduce using rule 48 (expr -> NOT expr .)
    RP              reduce using rule 48 (expr -> NOT expr .)

  ! OR              [ shift and go to state 60 ]
  ! AND             [ shift and go to state 61 ]


state 63

    (35) aexpr -> TYPE LP . aexpr RP
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    aexpr                          shift and go to state 88

state 64

    (16) if -> IF LP expr . RP COLON block elif else END
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr

    RP              shift and go to state 89
    OR              shift and go to state 60
    AND             shift and go to state 61


state 65

    (10) assign -> NAME ASSIGN expr .
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr

    SEMICOLON       reduce using rule 10 (assign -> NAME ASSIGN expr .)
    OR              shift and go to state 60
    AND             shift and go to state 61


state 66

    (9) declare -> TYPE NAME ASSIGN . expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . aexpr EQ aexpr
    (43) expr -> . aexpr NEQ aexpr
    (44) expr -> . aexpr GT aexpr
    (45) expr -> . aexpr GET aexpr
    (46) expr -> . aexpr LT aexpr
    (47) expr -> . aexpr LET aexpr
    (48) expr -> . NOT expr
    (49) expr -> . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    NOT             shift and go to state 32
    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    expr                           shift and go to state 90
    aexpr                          shift and go to state 25

state 67

    (15) while -> WHILE LP expr RP . COLON block END

    COLON           shift and go to state 91


state 68

    (44) expr -> aexpr GT aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    OR              reduce using rule 44 (expr -> aexpr GT aexpr .)
    AND             reduce using rule 44 (expr -> aexpr GT aexpr .)
    SEMICOLON       reduce using rule 44 (expr -> aexpr GT aexpr .)
    RP              reduce using rule 44 (expr -> aexpr GT aexpr .)
    BOR             shift and go to state 47
    BXOR            shift and go to state 46
    BAND            shift and go to state 50
    BRSHIFT         shift and go to state 49
    BLSHIFT         shift and go to state 48
    PLUS            shift and go to state 55
    MINUS           shift and go to state 54
    TIMES           shift and go to state 56
    MODS            shift and go to state 52
    DIVIDES         shift and go to state 43
    EXP             shift and go to state 44


state 69

    (30) aexpr -> aexpr DIVIDES aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    BOR             reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    BXOR            reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    BAND            reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    BRSHIFT         reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    BLSHIFT         reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    PLUS            reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    MINUS           reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    TIMES           reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    MODS            reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    DIVIDES         reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    EQ              reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    NEQ             reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    GT              reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    GET             reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    LT              reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    LET             reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    OR              reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    AND             reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    SEMICOLON       reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    RP              reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .)
    EXP             shift and go to state 44

  ! EXP             [ reduce using rule 30 (aexpr -> aexpr DIVIDES aexpr .) ]
  ! BOR             [ shift and go to state 47 ]
  ! BXOR            [ shift and go to state 46 ]
  ! BAND            [ shift and go to state 50 ]
  ! BRSHIFT         [ shift and go to state 49 ]
  ! BLSHIFT         [ shift and go to state 48 ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 54 ]
  ! TIMES           [ shift and go to state 56 ]
  ! MODS            [ shift and go to state 52 ]
  ! DIVIDES         [ shift and go to state 43 ]


state 70

    (31) aexpr -> aexpr EXP aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    BOR             reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    BXOR            reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    BAND            reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    BRSHIFT         reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    BLSHIFT         reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    PLUS            reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    MINUS           reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    TIMES           reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    MODS            reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    DIVIDES         reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    EXP             reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    EQ              reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    NEQ             reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    GT              reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    GET             reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    LT              reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    LET             reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    OR              reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    AND             reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    SEMICOLON       reduce using rule 31 (aexpr -> aexpr EXP aexpr .)
    RP              reduce using rule 31 (aexpr -> aexpr EXP aexpr .)

  ! BOR             [ shift and go to state 47 ]
  ! BXOR            [ shift and go to state 46 ]
  ! BAND            [ shift and go to state 50 ]
  ! BRSHIFT         [ shift and go to state 49 ]
  ! BLSHIFT         [ shift and go to state 48 ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 54 ]
  ! TIMES           [ shift and go to state 56 ]
  ! MODS            [ shift and go to state 52 ]
  ! DIVIDES         [ shift and go to state 43 ]
  ! EXP             [ shift and go to state 44 ]


state 71

    (45) expr -> aexpr GET aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    OR              reduce using rule 45 (expr -> aexpr GET aexpr .)
    AND             reduce using rule 45 (expr -> aexpr GET aexpr .)
    SEMICOLON       reduce using rule 45 (expr -> aexpr GET aexpr .)
    RP              reduce using rule 45 (expr -> aexpr GET aexpr .)
    BOR             shift and go to state 47
    BXOR            shift and go to state 46
    BAND            shift and go to state 50
    BRSHIFT         shift and go to state 49
    BLSHIFT         shift and go to state 48
    PLUS            shift and go to state 55
    MINUS           shift and go to state 54
    TIMES           shift and go to state 56
    MODS            shift and go to state 52
    DIVIDES         shift and go to state 43
    EXP             shift and go to state 44


state 72

    (22) aexpr -> aexpr BXOR aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    BOR             reduce using rule 22 (aexpr -> aexpr BXOR aexpr .)
    BXOR            reduce using rule 22 (aexpr -> aexpr BXOR aexpr .)
    EQ              reduce using rule 22 (aexpr -> aexpr BXOR aexpr .)
    NEQ             reduce using rule 22 (aexpr -> aexpr BXOR aexpr .)
    GT              reduce using rule 22 (aexpr -> aexpr BXOR aexpr .)
    GET             reduce using rule 22 (aexpr -> aexpr BXOR aexpr .)
    LT              reduce using rule 22 (aexpr -> aexpr BXOR aexpr .)
    LET             reduce using rule 22 (aexpr -> aexpr BXOR aexpr .)
    OR              reduce using rule 22 (aexpr -> aexpr BXOR aexpr .)
    AND             reduce using rule 22 (aexpr -> aexpr BXOR aexpr .)
    SEMICOLON       reduce using rule 22 (aexpr -> aexpr BXOR aexpr .)
    RP              reduce using rule 22 (aexpr -> aexpr BXOR aexpr .)
    BAND            shift and go to state 50
    BRSHIFT         shift and go to state 49
    BLSHIFT         shift and go to state 48
    PLUS            shift and go to state 55
    MINUS           shift and go to state 54
    TIMES           shift and go to state 56
    MODS            shift and go to state 52
    DIVIDES         shift and go to state 43
    EXP             shift and go to state 44

  ! BAND            [ reduce using rule 22 (aexpr -> aexpr BXOR aexpr .) ]
  ! BRSHIFT         [ reduce using rule 22 (aexpr -> aexpr BXOR aexpr .) ]
  ! BLSHIFT         [ reduce using rule 22 (aexpr -> aexpr BXOR aexpr .) ]
  ! PLUS            [ reduce using rule 22 (aexpr -> aexpr BXOR aexpr .) ]
  ! MINUS           [ reduce using rule 22 (aexpr -> aexpr BXOR aexpr .) ]
  ! TIMES           [ reduce using rule 22 (aexpr -> aexpr BXOR aexpr .) ]
  ! MODS            [ reduce using rule 22 (aexpr -> aexpr BXOR aexpr .) ]
  ! DIVIDES         [ reduce using rule 22 (aexpr -> aexpr BXOR aexpr .) ]
  ! EXP             [ reduce using rule 22 (aexpr -> aexpr BXOR aexpr .) ]
  ! BOR             [ shift and go to state 47 ]
  ! BXOR            [ shift and go to state 46 ]


state 73

    (21) aexpr -> aexpr BOR aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    BOR             reduce using rule 21 (aexpr -> aexpr BOR aexpr .)
    EQ              reduce using rule 21 (aexpr -> aexpr BOR aexpr .)
    NEQ             reduce using rule 21 (aexpr -> aexpr BOR aexpr .)
    GT              reduce using rule 21 (aexpr -> aexpr BOR aexpr .)
    GET             reduce using rule 21 (aexpr -> aexpr BOR aexpr .)
    LT              reduce using rule 21 (aexpr -> aexpr BOR aexpr .)
    LET             reduce using rule 21 (aexpr -> aexpr BOR aexpr .)
    OR              reduce using rule 21 (aexpr -> aexpr BOR aexpr .)
    AND             reduce using rule 21 (aexpr -> aexpr BOR aexpr .)
    SEMICOLON       reduce using rule 21 (aexpr -> aexpr BOR aexpr .)
    RP              reduce using rule 21 (aexpr -> aexpr BOR aexpr .)
    BXOR            shift and go to state 46
    BAND            shift and go to state 50
    BRSHIFT         shift and go to state 49
    BLSHIFT         shift and go to state 48
    PLUS            shift and go to state 55
    MINUS           shift and go to state 54
    TIMES           shift and go to state 56
    MODS            shift and go to state 52
    DIVIDES         shift and go to state 43
    EXP             shift and go to state 44

  ! BXOR            [ reduce using rule 21 (aexpr -> aexpr BOR aexpr .) ]
  ! BAND            [ reduce using rule 21 (aexpr -> aexpr BOR aexpr .) ]
  ! BRSHIFT         [ reduce using rule 21 (aexpr -> aexpr BOR aexpr .) ]
  ! BLSHIFT         [ reduce using rule 21 (aexpr -> aexpr BOR aexpr .) ]
  ! PLUS            [ reduce using rule 21 (aexpr -> aexpr BOR aexpr .) ]
  ! MINUS           [ reduce using rule 21 (aexpr -> aexpr BOR aexpr .) ]
  ! TIMES           [ reduce using rule 21 (aexpr -> aexpr BOR aexpr .) ]
  ! MODS            [ reduce using rule 21 (aexpr -> aexpr BOR aexpr .) ]
  ! DIVIDES         [ reduce using rule 21 (aexpr -> aexpr BOR aexpr .) ]
  ! EXP             [ reduce using rule 21 (aexpr -> aexpr BOR aexpr .) ]
  ! BOR             [ shift and go to state 47 ]


state 74

    (25) aexpr -> aexpr BLSHIFT aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    BOR             reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .)
    BXOR            reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .)
    BAND            reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .)
    BRSHIFT         reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .)
    BLSHIFT         reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .)
    EQ              reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .)
    NEQ             reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .)
    GT              reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .)
    GET             reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .)
    LT              reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .)
    LET             reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .)
    OR              reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .)
    AND             reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .)
    SEMICOLON       reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .)
    RP              reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 54
    TIMES           shift and go to state 56
    MODS            shift and go to state 52
    DIVIDES         shift and go to state 43
    EXP             shift and go to state 44

  ! PLUS            [ reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .) ]
  ! MINUS           [ reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .) ]
  ! TIMES           [ reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .) ]
  ! MODS            [ reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .) ]
  ! DIVIDES         [ reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .) ]
  ! EXP             [ reduce using rule 25 (aexpr -> aexpr BLSHIFT aexpr .) ]
  ! BOR             [ shift and go to state 47 ]
  ! BXOR            [ shift and go to state 46 ]
  ! BAND            [ shift and go to state 50 ]
  ! BRSHIFT         [ shift and go to state 49 ]
  ! BLSHIFT         [ shift and go to state 48 ]


state 75

    (24) aexpr -> aexpr BRSHIFT aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    BOR             reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .)
    BXOR            reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .)
    BAND            reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .)
    BRSHIFT         reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .)
    BLSHIFT         reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .)
    EQ              reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .)
    NEQ             reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .)
    GT              reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .)
    GET             reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .)
    LT              reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .)
    LET             reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .)
    OR              reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .)
    AND             reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .)
    SEMICOLON       reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .)
    RP              reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 54
    TIMES           shift and go to state 56
    MODS            shift and go to state 52
    DIVIDES         shift and go to state 43
    EXP             shift and go to state 44

  ! PLUS            [ reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .) ]
  ! MINUS           [ reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .) ]
  ! TIMES           [ reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .) ]
  ! MODS            [ reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .) ]
  ! DIVIDES         [ reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .) ]
  ! EXP             [ reduce using rule 24 (aexpr -> aexpr BRSHIFT aexpr .) ]
  ! BOR             [ shift and go to state 47 ]
  ! BXOR            [ shift and go to state 46 ]
  ! BAND            [ shift and go to state 50 ]
  ! BRSHIFT         [ shift and go to state 49 ]
  ! BLSHIFT         [ shift and go to state 48 ]


state 76

    (23) aexpr -> aexpr BAND aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    BOR             reduce using rule 23 (aexpr -> aexpr BAND aexpr .)
    BXOR            reduce using rule 23 (aexpr -> aexpr BAND aexpr .)
    BAND            reduce using rule 23 (aexpr -> aexpr BAND aexpr .)
    EQ              reduce using rule 23 (aexpr -> aexpr BAND aexpr .)
    NEQ             reduce using rule 23 (aexpr -> aexpr BAND aexpr .)
    GT              reduce using rule 23 (aexpr -> aexpr BAND aexpr .)
    GET             reduce using rule 23 (aexpr -> aexpr BAND aexpr .)
    LT              reduce using rule 23 (aexpr -> aexpr BAND aexpr .)
    LET             reduce using rule 23 (aexpr -> aexpr BAND aexpr .)
    OR              reduce using rule 23 (aexpr -> aexpr BAND aexpr .)
    AND             reduce using rule 23 (aexpr -> aexpr BAND aexpr .)
    SEMICOLON       reduce using rule 23 (aexpr -> aexpr BAND aexpr .)
    RP              reduce using rule 23 (aexpr -> aexpr BAND aexpr .)
    BRSHIFT         shift and go to state 49
    BLSHIFT         shift and go to state 48
    PLUS            shift and go to state 55
    MINUS           shift and go to state 54
    TIMES           shift and go to state 56
    MODS            shift and go to state 52
    DIVIDES         shift and go to state 43
    EXP             shift and go to state 44

  ! BRSHIFT         [ reduce using rule 23 (aexpr -> aexpr BAND aexpr .) ]
  ! BLSHIFT         [ reduce using rule 23 (aexpr -> aexpr BAND aexpr .) ]
  ! PLUS            [ reduce using rule 23 (aexpr -> aexpr BAND aexpr .) ]
  ! MINUS           [ reduce using rule 23 (aexpr -> aexpr BAND aexpr .) ]
  ! TIMES           [ reduce using rule 23 (aexpr -> aexpr BAND aexpr .) ]
  ! MODS            [ reduce using rule 23 (aexpr -> aexpr BAND aexpr .) ]
  ! DIVIDES         [ reduce using rule 23 (aexpr -> aexpr BAND aexpr .) ]
  ! EXP             [ reduce using rule 23 (aexpr -> aexpr BAND aexpr .) ]
  ! BOR             [ shift and go to state 47 ]
  ! BXOR            [ shift and go to state 46 ]
  ! BAND            [ shift and go to state 50 ]


state 77

    (46) expr -> aexpr LT aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    OR              reduce using rule 46 (expr -> aexpr LT aexpr .)
    AND             reduce using rule 46 (expr -> aexpr LT aexpr .)
    SEMICOLON       reduce using rule 46 (expr -> aexpr LT aexpr .)
    RP              reduce using rule 46 (expr -> aexpr LT aexpr .)
    BOR             shift and go to state 47
    BXOR            shift and go to state 46
    BAND            shift and go to state 50
    BRSHIFT         shift and go to state 49
    BLSHIFT         shift and go to state 48
    PLUS            shift and go to state 55
    MINUS           shift and go to state 54
    TIMES           shift and go to state 56
    MODS            shift and go to state 52
    DIVIDES         shift and go to state 43
    EXP             shift and go to state 44


state 78

    (29) aexpr -> aexpr MODS aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    BOR             reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    BXOR            reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    BAND            reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    BRSHIFT         reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    BLSHIFT         reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    PLUS            reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    MINUS           reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    TIMES           reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    MODS            reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    DIVIDES         reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    EQ              reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    NEQ             reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    GT              reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    GET             reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    LT              reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    LET             reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    OR              reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    AND             reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    SEMICOLON       reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    RP              reduce using rule 29 (aexpr -> aexpr MODS aexpr .)
    EXP             shift and go to state 44

  ! EXP             [ reduce using rule 29 (aexpr -> aexpr MODS aexpr .) ]
  ! BOR             [ shift and go to state 47 ]
  ! BXOR            [ shift and go to state 46 ]
  ! BAND            [ shift and go to state 50 ]
  ! BRSHIFT         [ shift and go to state 49 ]
  ! BLSHIFT         [ shift and go to state 48 ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 54 ]
  ! TIMES           [ shift and go to state 56 ]
  ! MODS            [ shift and go to state 52 ]
  ! DIVIDES         [ shift and go to state 43 ]


state 79

    (47) expr -> aexpr LET aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    OR              reduce using rule 47 (expr -> aexpr LET aexpr .)
    AND             reduce using rule 47 (expr -> aexpr LET aexpr .)
    SEMICOLON       reduce using rule 47 (expr -> aexpr LET aexpr .)
    RP              reduce using rule 47 (expr -> aexpr LET aexpr .)
    BOR             shift and go to state 47
    BXOR            shift and go to state 46
    BAND            shift and go to state 50
    BRSHIFT         shift and go to state 49
    BLSHIFT         shift and go to state 48
    PLUS            shift and go to state 55
    MINUS           shift and go to state 54
    TIMES           shift and go to state 56
    MODS            shift and go to state 52
    DIVIDES         shift and go to state 43
    EXP             shift and go to state 44


state 80

    (27) aexpr -> aexpr MINUS aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    BOR             reduce using rule 27 (aexpr -> aexpr MINUS aexpr .)
    BXOR            reduce using rule 27 (aexpr -> aexpr MINUS aexpr .)
    BAND            reduce using rule 27 (aexpr -> aexpr MINUS aexpr .)
    BRSHIFT         reduce using rule 27 (aexpr -> aexpr MINUS aexpr .)
    BLSHIFT         reduce using rule 27 (aexpr -> aexpr MINUS aexpr .)
    PLUS            reduce using rule 27 (aexpr -> aexpr MINUS aexpr .)
    MINUS           reduce using rule 27 (aexpr -> aexpr MINUS aexpr .)
    EQ              reduce using rule 27 (aexpr -> aexpr MINUS aexpr .)
    NEQ             reduce using rule 27 (aexpr -> aexpr MINUS aexpr .)
    GT              reduce using rule 27 (aexpr -> aexpr MINUS aexpr .)
    GET             reduce using rule 27 (aexpr -> aexpr MINUS aexpr .)
    LT              reduce using rule 27 (aexpr -> aexpr MINUS aexpr .)
    LET             reduce using rule 27 (aexpr -> aexpr MINUS aexpr .)
    OR              reduce using rule 27 (aexpr -> aexpr MINUS aexpr .)
    AND             reduce using rule 27 (aexpr -> aexpr MINUS aexpr .)
    SEMICOLON       reduce using rule 27 (aexpr -> aexpr MINUS aexpr .)
    RP              reduce using rule 27 (aexpr -> aexpr MINUS aexpr .)
    TIMES           shift and go to state 56
    MODS            shift and go to state 52
    DIVIDES         shift and go to state 43
    EXP             shift and go to state 44

  ! TIMES           [ reduce using rule 27 (aexpr -> aexpr MINUS aexpr .) ]
  ! MODS            [ reduce using rule 27 (aexpr -> aexpr MINUS aexpr .) ]
  ! DIVIDES         [ reduce using rule 27 (aexpr -> aexpr MINUS aexpr .) ]
  ! EXP             [ reduce using rule 27 (aexpr -> aexpr MINUS aexpr .) ]
  ! BOR             [ shift and go to state 47 ]
  ! BXOR            [ shift and go to state 46 ]
  ! BAND            [ shift and go to state 50 ]
  ! BRSHIFT         [ shift and go to state 49 ]
  ! BLSHIFT         [ shift and go to state 48 ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 54 ]


state 81

    (26) aexpr -> aexpr PLUS aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    BOR             reduce using rule 26 (aexpr -> aexpr PLUS aexpr .)
    BXOR            reduce using rule 26 (aexpr -> aexpr PLUS aexpr .)
    BAND            reduce using rule 26 (aexpr -> aexpr PLUS aexpr .)
    BRSHIFT         reduce using rule 26 (aexpr -> aexpr PLUS aexpr .)
    BLSHIFT         reduce using rule 26 (aexpr -> aexpr PLUS aexpr .)
    PLUS            reduce using rule 26 (aexpr -> aexpr PLUS aexpr .)
    MINUS           reduce using rule 26 (aexpr -> aexpr PLUS aexpr .)
    EQ              reduce using rule 26 (aexpr -> aexpr PLUS aexpr .)
    NEQ             reduce using rule 26 (aexpr -> aexpr PLUS aexpr .)
    GT              reduce using rule 26 (aexpr -> aexpr PLUS aexpr .)
    GET             reduce using rule 26 (aexpr -> aexpr PLUS aexpr .)
    LT              reduce using rule 26 (aexpr -> aexpr PLUS aexpr .)
    LET             reduce using rule 26 (aexpr -> aexpr PLUS aexpr .)
    OR              reduce using rule 26 (aexpr -> aexpr PLUS aexpr .)
    AND             reduce using rule 26 (aexpr -> aexpr PLUS aexpr .)
    SEMICOLON       reduce using rule 26 (aexpr -> aexpr PLUS aexpr .)
    RP              reduce using rule 26 (aexpr -> aexpr PLUS aexpr .)
    TIMES           shift and go to state 56
    MODS            shift and go to state 52
    DIVIDES         shift and go to state 43
    EXP             shift and go to state 44

  ! TIMES           [ reduce using rule 26 (aexpr -> aexpr PLUS aexpr .) ]
  ! MODS            [ reduce using rule 26 (aexpr -> aexpr PLUS aexpr .) ]
  ! DIVIDES         [ reduce using rule 26 (aexpr -> aexpr PLUS aexpr .) ]
  ! EXP             [ reduce using rule 26 (aexpr -> aexpr PLUS aexpr .) ]
  ! BOR             [ shift and go to state 47 ]
  ! BXOR            [ shift and go to state 46 ]
  ! BAND            [ shift and go to state 50 ]
  ! BRSHIFT         [ shift and go to state 49 ]
  ! BLSHIFT         [ shift and go to state 48 ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 54 ]


state 82

    (28) aexpr -> aexpr TIMES aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    BOR             reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    BXOR            reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    BAND            reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    BRSHIFT         reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    BLSHIFT         reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    PLUS            reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    MINUS           reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    TIMES           reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    MODS            reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    DIVIDES         reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    EQ              reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    NEQ             reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    GT              reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    GET             reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    LT              reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    LET             reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    OR              reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    AND             reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    SEMICOLON       reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    RP              reduce using rule 28 (aexpr -> aexpr TIMES aexpr .)
    EXP             shift and go to state 44

  ! EXP             [ reduce using rule 28 (aexpr -> aexpr TIMES aexpr .) ]
  ! BOR             [ shift and go to state 47 ]
  ! BXOR            [ shift and go to state 46 ]
  ! BAND            [ shift and go to state 50 ]
  ! BRSHIFT         [ shift and go to state 49 ]
  ! BLSHIFT         [ shift and go to state 48 ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 54 ]
  ! TIMES           [ shift and go to state 56 ]
  ! MODS            [ shift and go to state 52 ]
  ! DIVIDES         [ shift and go to state 43 ]


state 83

    (42) expr -> aexpr EQ aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    OR              reduce using rule 42 (expr -> aexpr EQ aexpr .)
    AND             reduce using rule 42 (expr -> aexpr EQ aexpr .)
    SEMICOLON       reduce using rule 42 (expr -> aexpr EQ aexpr .)
    RP              reduce using rule 42 (expr -> aexpr EQ aexpr .)
    BOR             shift and go to state 47
    BXOR            shift and go to state 46
    BAND            shift and go to state 50
    BRSHIFT         shift and go to state 49
    BLSHIFT         shift and go to state 48
    PLUS            shift and go to state 55
    MINUS           shift and go to state 54
    TIMES           shift and go to state 56
    MODS            shift and go to state 52
    DIVIDES         shift and go to state 43
    EXP             shift and go to state 44


state 84

    (43) expr -> aexpr NEQ aexpr .
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    OR              reduce using rule 43 (expr -> aexpr NEQ aexpr .)
    AND             reduce using rule 43 (expr -> aexpr NEQ aexpr .)
    SEMICOLON       reduce using rule 43 (expr -> aexpr NEQ aexpr .)
    RP              reduce using rule 43 (expr -> aexpr NEQ aexpr .)
    BOR             shift and go to state 47
    BXOR            shift and go to state 46
    BAND            shift and go to state 50
    BRSHIFT         shift and go to state 49
    BLSHIFT         shift and go to state 48
    PLUS            shift and go to state 55
    MINUS           shift and go to state 54
    TIMES           shift and go to state 56
    MODS            shift and go to state 52
    DIVIDES         shift and go to state 43
    EXP             shift and go to state 44


state 85

    (34) aexpr -> LP aexpr RP .

    BOR             reduce using rule 34 (aexpr -> LP aexpr RP .)
    BXOR            reduce using rule 34 (aexpr -> LP aexpr RP .)
    BAND            reduce using rule 34 (aexpr -> LP aexpr RP .)
    BRSHIFT         reduce using rule 34 (aexpr -> LP aexpr RP .)
    BLSHIFT         reduce using rule 34 (aexpr -> LP aexpr RP .)
    PLUS            reduce using rule 34 (aexpr -> LP aexpr RP .)
    MINUS           reduce using rule 34 (aexpr -> LP aexpr RP .)
    TIMES           reduce using rule 34 (aexpr -> LP aexpr RP .)
    MODS            reduce using rule 34 (aexpr -> LP aexpr RP .)
    DIVIDES         reduce using rule 34 (aexpr -> LP aexpr RP .)
    EXP             reduce using rule 34 (aexpr -> LP aexpr RP .)
    EQ              reduce using rule 34 (aexpr -> LP aexpr RP .)
    NEQ             reduce using rule 34 (aexpr -> LP aexpr RP .)
    GT              reduce using rule 34 (aexpr -> LP aexpr RP .)
    GET             reduce using rule 34 (aexpr -> LP aexpr RP .)
    LT              reduce using rule 34 (aexpr -> LP aexpr RP .)
    LET             reduce using rule 34 (aexpr -> LP aexpr RP .)
    OR              reduce using rule 34 (aexpr -> LP aexpr RP .)
    AND             reduce using rule 34 (aexpr -> LP aexpr RP .)
    SEMICOLON       reduce using rule 34 (aexpr -> LP aexpr RP .)
    RP              reduce using rule 34 (aexpr -> LP aexpr RP .)


state 86

    (40) expr -> expr OR expr .
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr

    OR              reduce using rule 40 (expr -> expr OR expr .)
    SEMICOLON       reduce using rule 40 (expr -> expr OR expr .)
    RP              reduce using rule 40 (expr -> expr OR expr .)
    AND             shift and go to state 61

  ! AND             [ reduce using rule 40 (expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 60 ]


state 87

    (41) expr -> expr AND expr .
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr

    OR              reduce using rule 41 (expr -> expr AND expr .)
    AND             reduce using rule 41 (expr -> expr AND expr .)
    SEMICOLON       reduce using rule 41 (expr -> expr AND expr .)
    RP              reduce using rule 41 (expr -> expr AND expr .)

  ! OR              [ shift and go to state 60 ]
  ! AND             [ shift and go to state 61 ]


state 88

    (35) aexpr -> TYPE LP aexpr . RP
    (21) aexpr -> aexpr . BOR aexpr
    (22) aexpr -> aexpr . BXOR aexpr
    (23) aexpr -> aexpr . BAND aexpr
    (24) aexpr -> aexpr . BRSHIFT aexpr
    (25) aexpr -> aexpr . BLSHIFT aexpr
    (26) aexpr -> aexpr . PLUS aexpr
    (27) aexpr -> aexpr . MINUS aexpr
    (28) aexpr -> aexpr . TIMES aexpr
    (29) aexpr -> aexpr . MODS aexpr
    (30) aexpr -> aexpr . DIVIDES aexpr
    (31) aexpr -> aexpr . EXP aexpr

    RP              shift and go to state 92
    BOR             shift and go to state 47
    BXOR            shift and go to state 46
    BAND            shift and go to state 50
    BRSHIFT         shift and go to state 49
    BLSHIFT         shift and go to state 48
    PLUS            shift and go to state 55
    MINUS           shift and go to state 54
    TIMES           shift and go to state 56
    MODS            shift and go to state 52
    DIVIDES         shift and go to state 43
    EXP             shift and go to state 44


state 89

    (16) if -> IF LP expr RP . COLON block elif else END

    COLON           shift and go to state 93


state 90

    (9) declare -> TYPE NAME ASSIGN expr .
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr

    SEMICOLON       reduce using rule 9 (declare -> TYPE NAME ASSIGN expr .)
    OR              shift and go to state 60
    AND             shift and go to state 61


state 91

    (15) while -> WHILE LP expr RP COLON . block END
    (1) block -> . block sentence
    (2) block -> .

    END             reduce using rule 2 (block -> .)
    TYPE            reduce using rule 2 (block -> .)
    NAME            reduce using rule 2 (block -> .)
    BREAK           reduce using rule 2 (block -> .)
    CONTINUE        reduce using rule 2 (block -> .)
    READ            reduce using rule 2 (block -> .)
    WRITE           reduce using rule 2 (block -> .)
    WHILE           reduce using rule 2 (block -> .)
    IF              reduce using rule 2 (block -> .)

    block                          shift and go to state 94

state 92

    (35) aexpr -> TYPE LP aexpr RP .

    BOR             reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    BXOR            reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    BAND            reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    BRSHIFT         reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    BLSHIFT         reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    PLUS            reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    MINUS           reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    TIMES           reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    MODS            reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    DIVIDES         reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    EXP             reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    EQ              reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    NEQ             reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    GT              reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    GET             reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    LT              reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    LET             reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    OR              reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    AND             reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    SEMICOLON       reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)
    RP              reduce using rule 35 (aexpr -> TYPE LP aexpr RP .)


state 93

    (16) if -> IF LP expr RP COLON . block elif else END
    (1) block -> . block sentence
    (2) block -> .

    TYPE            reduce using rule 2 (block -> .)
    NAME            reduce using rule 2 (block -> .)
    BREAK           reduce using rule 2 (block -> .)
    CONTINUE        reduce using rule 2 (block -> .)
    READ            reduce using rule 2 (block -> .)
    WRITE           reduce using rule 2 (block -> .)
    WHILE           reduce using rule 2 (block -> .)
    IF              reduce using rule 2 (block -> .)
    ELIF            reduce using rule 2 (block -> .)
    ELSE            reduce using rule 2 (block -> .)
    END             reduce using rule 2 (block -> .)

    block                          shift and go to state 95

state 94

    (15) while -> WHILE LP expr RP COLON block . END
    (1) block -> block . sentence
    (3) sentence -> . declare SEMICOLON
    (4) sentence -> . assign SEMICOLON
    (5) sentence -> . control SEMICOLON
    (6) sentence -> . read SEMICOLON
    (7) sentence -> . write SEMICOLON
    (8) declare -> . TYPE NAME
    (9) declare -> . TYPE NAME ASSIGN expr
    (10) assign -> . NAME ASSIGN expr
    (11) control -> . while
    (12) control -> . if
    (13) control -> . BREAK
    (14) control -> . CONTINUE
    (50) read -> . READ NAME
    (51) write -> . WRITE expr
    (15) while -> . WHILE LP expr RP COLON block END
    (16) if -> . IF LP expr RP COLON block elif else END

    END             shift and go to state 96
    TYPE            shift and go to state 16
    NAME            shift and go to state 11
    BREAK           shift and go to state 13
    CONTINUE        shift and go to state 15
    READ            shift and go to state 4
    WRITE           shift and go to state 9
    WHILE           shift and go to state 5
    IF              shift and go to state 10

    control                        shift and go to state 2
    sentence                       shift and go to state 3
    read                           shift and go to state 8
    declare                        shift and go to state 17
    write                          shift and go to state 7
    while                          shift and go to state 14
    assign                         shift and go to state 12
    if                             shift and go to state 6

state 95

    (16) if -> IF LP expr RP COLON block . elif else END
    (1) block -> block . sentence
    (17) elif -> . elif ELIF LP expr RP COLON block
    (18) elif -> .
    (3) sentence -> . declare SEMICOLON
    (4) sentence -> . assign SEMICOLON
    (5) sentence -> . control SEMICOLON
    (6) sentence -> . read SEMICOLON
    (7) sentence -> . write SEMICOLON
    (8) declare -> . TYPE NAME
    (9) declare -> . TYPE NAME ASSIGN expr
    (10) assign -> . NAME ASSIGN expr
    (11) control -> . while
    (12) control -> . if
    (13) control -> . BREAK
    (14) control -> . CONTINUE
    (50) read -> . READ NAME
    (51) write -> . WRITE expr
    (15) while -> . WHILE LP expr RP COLON block END
    (16) if -> . IF LP expr RP COLON block elif else END

    ELIF            reduce using rule 18 (elif -> .)
    ELSE            reduce using rule 18 (elif -> .)
    END             reduce using rule 18 (elif -> .)
    TYPE            shift and go to state 16
    NAME            shift and go to state 11
    BREAK           shift and go to state 13
    CONTINUE        shift and go to state 15
    READ            shift and go to state 4
    WRITE           shift and go to state 9
    WHILE           shift and go to state 5
    IF              shift and go to state 10

    control                        shift and go to state 2
    elif                           shift and go to state 97
    assign                         shift and go to state 12
    sentence                       shift and go to state 3
    read                           shift and go to state 8
    write                          shift and go to state 7
    while                          shift and go to state 14
    declare                        shift and go to state 17
    if                             shift and go to state 6

state 96

    (15) while -> WHILE LP expr RP COLON block END .

    SEMICOLON       reduce using rule 15 (while -> WHILE LP expr RP COLON block END .)


state 97

    (16) if -> IF LP expr RP COLON block elif . else END
    (17) elif -> elif . ELIF LP expr RP COLON block
    (19) else -> . ELSE COLON block
    (20) else -> .

    ELIF            shift and go to state 98
    ELSE            shift and go to state 100
    END             reduce using rule 20 (else -> .)

    else                           shift and go to state 99

state 98

    (17) elif -> elif ELIF . LP expr RP COLON block

    LP              shift and go to state 101


state 99

    (16) if -> IF LP expr RP COLON block elif else . END

    END             shift and go to state 102


state 100

    (19) else -> ELSE . COLON block

    COLON           shift and go to state 103


state 101

    (17) elif -> elif ELIF LP . expr RP COLON block
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . aexpr EQ aexpr
    (43) expr -> . aexpr NEQ aexpr
    (44) expr -> . aexpr GT aexpr
    (45) expr -> . aexpr GET aexpr
    (46) expr -> . aexpr LT aexpr
    (47) expr -> . aexpr LET aexpr
    (48) expr -> . NOT expr
    (49) expr -> . aexpr
    (21) aexpr -> . aexpr BOR aexpr
    (22) aexpr -> . aexpr BXOR aexpr
    (23) aexpr -> . aexpr BAND aexpr
    (24) aexpr -> . aexpr BRSHIFT aexpr
    (25) aexpr -> . aexpr BLSHIFT aexpr
    (26) aexpr -> . aexpr PLUS aexpr
    (27) aexpr -> . aexpr MINUS aexpr
    (28) aexpr -> . aexpr TIMES aexpr
    (29) aexpr -> . aexpr MODS aexpr
    (30) aexpr -> . aexpr DIVIDES aexpr
    (31) aexpr -> . aexpr EXP aexpr
    (32) aexpr -> . MINUS aexpr
    (33) aexpr -> . BNOT aexpr
    (34) aexpr -> . LP aexpr RP
    (35) aexpr -> . TYPE LP aexpr RP
    (36) aexpr -> . INT
    (37) aexpr -> . FLOAT
    (38) aexpr -> . BOOL
    (39) aexpr -> . NAME

    NOT             shift and go to state 32
    MINUS           shift and go to state 24
    BNOT            shift and go to state 23
    LP              shift and go to state 26
    TYPE            shift and go to state 33
    INT             shift and go to state 29
    FLOAT           shift and go to state 31
    BOOL            shift and go to state 27
    NAME            shift and go to state 28

    expr                           shift and go to state 104
    aexpr                          shift and go to state 25

state 102

    (16) if -> IF LP expr RP COLON block elif else END .

    SEMICOLON       reduce using rule 16 (if -> IF LP expr RP COLON block elif else END .)


state 103

    (19) else -> ELSE COLON . block
    (1) block -> . block sentence
    (2) block -> .

    TYPE            reduce using rule 2 (block -> .)
    NAME            reduce using rule 2 (block -> .)
    BREAK           reduce using rule 2 (block -> .)
    CONTINUE        reduce using rule 2 (block -> .)
    READ            reduce using rule 2 (block -> .)
    WRITE           reduce using rule 2 (block -> .)
    WHILE           reduce using rule 2 (block -> .)
    IF              reduce using rule 2 (block -> .)
    END             reduce using rule 2 (block -> .)

    block                          shift and go to state 105

state 104

    (17) elif -> elif ELIF LP expr . RP COLON block
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr

    RP              shift and go to state 106
    OR              shift and go to state 60
    AND             shift and go to state 61


state 105

    (19) else -> ELSE COLON block .
    (1) block -> block . sentence
    (3) sentence -> . declare SEMICOLON
    (4) sentence -> . assign SEMICOLON
    (5) sentence -> . control SEMICOLON
    (6) sentence -> . read SEMICOLON
    (7) sentence -> . write SEMICOLON
    (8) declare -> . TYPE NAME
    (9) declare -> . TYPE NAME ASSIGN expr
    (10) assign -> . NAME ASSIGN expr
    (11) control -> . while
    (12) control -> . if
    (13) control -> . BREAK
    (14) control -> . CONTINUE
    (50) read -> . READ NAME
    (51) write -> . WRITE expr
    (15) while -> . WHILE LP expr RP COLON block END
    (16) if -> . IF LP expr RP COLON block elif else END

    END             reduce using rule 19 (else -> ELSE COLON block .)
    TYPE            shift and go to state 16
    NAME            shift and go to state 11
    BREAK           shift and go to state 13
    CONTINUE        shift and go to state 15
    READ            shift and go to state 4
    WRITE           shift and go to state 9
    WHILE           shift and go to state 5
    IF              shift and go to state 10

    control                        shift and go to state 2
    sentence                       shift and go to state 3
    read                           shift and go to state 8
    declare                        shift and go to state 17
    write                          shift and go to state 7
    while                          shift and go to state 14
    assign                         shift and go to state 12
    if                             shift and go to state 6

state 106

    (17) elif -> elif ELIF LP expr RP . COLON block

    COLON           shift and go to state 107


state 107

    (17) elif -> elif ELIF LP expr RP COLON . block
    (1) block -> . block sentence
    (2) block -> .

    TYPE            reduce using rule 2 (block -> .)
    NAME            reduce using rule 2 (block -> .)
    BREAK           reduce using rule 2 (block -> .)
    CONTINUE        reduce using rule 2 (block -> .)
    READ            reduce using rule 2 (block -> .)
    WRITE           reduce using rule 2 (block -> .)
    WHILE           reduce using rule 2 (block -> .)
    IF              reduce using rule 2 (block -> .)
    ELIF            reduce using rule 2 (block -> .)
    ELSE            reduce using rule 2 (block -> .)
    END             reduce using rule 2 (block -> .)

    block                          shift and go to state 108

state 108

    (17) elif -> elif ELIF LP expr RP COLON block .
    (1) block -> block . sentence
    (3) sentence -> . declare SEMICOLON
    (4) sentence -> . assign SEMICOLON
    (5) sentence -> . control SEMICOLON
    (6) sentence -> . read SEMICOLON
    (7) sentence -> . write SEMICOLON
    (8) declare -> . TYPE NAME
    (9) declare -> . TYPE NAME ASSIGN expr
    (10) assign -> . NAME ASSIGN expr
    (11) control -> . while
    (12) control -> . if
    (13) control -> . BREAK
    (14) control -> . CONTINUE
    (50) read -> . READ NAME
    (51) write -> . WRITE expr
    (15) while -> . WHILE LP expr RP COLON block END
    (16) if -> . IF LP expr RP COLON block elif else END

    ELIF            reduce using rule 17 (elif -> elif ELIF LP expr RP COLON block .)
    ELSE            reduce using rule 17 (elif -> elif ELIF LP expr RP COLON block .)
    END             reduce using rule 17 (elif -> elif ELIF LP expr RP COLON block .)
    TYPE            shift and go to state 16
    NAME            shift and go to state 11
    BREAK           shift and go to state 13
    CONTINUE        shift and go to state 15
    READ            shift and go to state 4
    WRITE           shift and go to state 9
    WHILE           shift and go to state 5
    IF              shift and go to state 10

    control                        shift and go to state 2
    sentence                       shift and go to state 3
    read                           shift and go to state 8
    declare                        shift and go to state 17
    write                          shift and go to state 7
    while                          shift and go to state 14
    assign                         shift and go to state 12
    if                             shift and go to state 6
